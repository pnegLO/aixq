{"ast":null,"code":"/**\n * 中国象棋 AI 算法\n * 实现 Alpha-Beta 剪枝搜索\n */\nimport { isValidMove, isCheck, COLORS, PIECE_TYPES } from './chessRules';\n\n// 棋子价值表（基础分值）\nconst PIECE_VALUES = {\n  [PIECE_TYPES.GENERAL]: 10000,\n  [PIECE_TYPES.ADVISOR]: 200,\n  [PIECE_TYPES.ELEPHANT]: 200,\n  [PIECE_TYPES.HORSE]: 400,\n  [PIECE_TYPES.CHARIOT]: 900,\n  [PIECE_TYPES.CANNON]: 450,\n  [PIECE_TYPES.SOLDIER]: 100\n};\n\n// 位置加成表（根据棋子在棋盘上的位置给予额外分数）\nconst POSITION_BONUSES = {\n  // 兵/卒位置价值表\n  [PIECE_TYPES.SOLDIER]: [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [30, 40, 50, 60, 70, 60, 50, 40, 30], [70, 80, 90, 100, 110, 100, 90, 80, 70], [80, 90, 100, 110, 120, 110, 100, 90, 80], [90, 100, 110, 120, 130, 120, 110, 100, 90], [90, 100, 110, 120, 130, 120, 110, 100, 90], [90, 100, 110, 120, 130, 120, 110, 100, 90], [90, 100, 110, 120, 130, 120, 110, 100, 90]],\n  // 马位置价值表 \n  [PIECE_TYPES.HORSE]: [[60, 70, 80, 90, 90, 90, 80, 70, 60], [70, 80, 90, 100, 100, 100, 90, 80, 70], [80, 90, 100, 110, 110, 110, 100, 90, 80], [90, 100, 110, 120, 120, 120, 110, 100, 90], [90, 100, 110, 120, 120, 120, 110, 100, 90], [90, 100, 110, 120, 120, 120, 110, 100, 90], [80, 90, 100, 110, 110, 110, 100, 90, 80], [70, 80, 90, 100, 100, 100, 90, 80, 70], [60, 70, 80, 90, 90, 90, 80, 70, 60], [50, 60, 70, 80, 80, 80, 70, 60, 50]]\n};\n\n/**\n * 生成当前棋盘所有合法移动\n * @param {Array} board - 棋盘状态\n * @param {String} color - 当前行动方颜色\n * @returns {Array} - 所有合法移动 [{fromRow, fromCol, toRow, toCol}, ...]\n */\nexport const generateAllMoves = (board, color) => {\n  const moves = [];\n\n  // 验证棋盘是否有效\n  if (!board || !Array.isArray(board) || board.length !== 10) {\n    return moves;\n  }\n  for (let fromRow = 0; fromRow < 10; fromRow++) {\n    for (let fromCol = 0; fromCol < 9; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        // 尝试所有可能的目标位置\n        for (let toRow = 0; toRow < 10; toRow++) {\n          for (let toCol = 0; toCol < 9; toCol++) {\n            // 过滤掉明显无效的移动以提高效率\n            if (fromRow === toRow && fromCol === toCol) continue;\n            try {\n              if (isValidMove(piece, board, fromRow, fromCol, toRow, toCol)) {\n                // 检查此移动是否会导致自己被将军\n                const tempBoard = JSON.parse(JSON.stringify(board));\n                tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n                tempBoard[fromRow][fromCol] = null;\n                if (!isCheck(tempBoard, color)) {\n                  moves.push({\n                    fromRow,\n                    fromCol,\n                    toRow,\n                    toCol\n                  });\n                }\n              }\n            } catch (error) {\n              console.error('Error in generateAllMoves:', error);\n              // 跳过有问题的移动\n              continue;\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n/**\n * 对棋盘进行评估，计算局势分数\n * 正分表示红方有利，负分表示黑方有利\n * @param {Array} board - 棋盘状态\n * @returns {Number} - 评估分数\n */\nexport const evaluateBoard = board => {\n  let score = 0;\n\n  // 检查棋盘是否有效\n  if (!board || !Array.isArray(board) || board.length !== 10) {\n    return 0;\n  }\n\n  // 计算每个棋子的基础价值和位置加成\n  for (let row = 0; row < 10; row++) {\n    if (!Array.isArray(board[row]) || board[row].length !== 9) {\n      continue; // 跳过无效的行\n    }\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (!piece) continue;\n\n      // 基础棋子价值\n      let pieceValue = PIECE_VALUES[piece.type] || 0;\n\n      // 位置加成（如果定义了该棋子类型的位置加成表）\n      if (POSITION_BONUSES[piece.type]) {\n        // 黑方棋子需要翻转位置加成表\n        const positionRow = piece.color === COLORS.RED ? row : 9 - row;\n        if (positionRow >= 0 && positionRow < 10 && POSITION_BONUSES[piece.type][positionRow]) {\n          pieceValue += POSITION_BONUSES[piece.type][positionRow][col] || 0;\n        }\n      }\n\n      // 红方加分，黑方减分\n      score += piece.color === COLORS.RED ? pieceValue : -pieceValue;\n    }\n  }\n  try {\n    // 检查将军状态，给予额外分数\n    if (isCheck(board, COLORS.BLACK)) {\n      score += 50; // 红方将军加分\n    }\n    if (isCheck(board, COLORS.RED)) {\n      score -= 50; // 黑方将军加分（红方减分）\n    }\n  } catch (error) {\n    console.error('Error checking isCheck in evaluateBoard:', error);\n  }\n  return score;\n};\n\n/**\n * 应用移动到棋盘（不改变原棋盘）\n * @param {Array} board - 原棋盘\n * @param {Object} move - 移动 {fromRow, fromCol, toRow, toCol}\n * @returns {Array} - 移动后的新棋盘\n */\nexport const applyMove = (board, move) => {\n  try {\n    if (!board || !Array.isArray(board) || board.length !== 10) {\n      console.error('Invalid board in applyMove');\n      return board; // 返回原始棋盘\n    }\n    if (!move || typeof move !== 'object') {\n      console.error('Invalid move in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n    const {\n      fromRow,\n      fromCol,\n      toRow,\n      toCol\n    } = move;\n\n    // 验证移动坐标\n    if (fromRow < 0 || fromRow >= 10 || fromCol < 0 || fromCol >= 9 || toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9) {\n      console.error('Invalid move coordinates in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n\n    // 验证起始位置有棋子\n    if (!board[fromRow] || !board[fromRow][fromCol]) {\n      console.error('No piece at source position in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n\n    // 创建新棋盘（深拷贝）\n    const newBoard = board.map(row => [...row]);\n\n    // 执行移动\n    newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n    newBoard[fromRow][fromCol] = null;\n    return newBoard;\n  } catch (error) {\n    console.error('Error in applyMove:', error);\n    return board; // 错误时返回原始棋盘\n  }\n};\n\n/**\n * Alpha-Beta 剪枝搜索算法\n * @param {Array} board - 当前棋盘状态\n * @param {Number} depth - 搜索深度\n * @param {Number} alpha - Alpha 值\n * @param {Number} beta - Beta 值\n * @param {Boolean} maximizingPlayer - 是否为最大化玩家（红方）\n * @returns {Object} - {score, move} 最佳分数和最佳移动\n */\nexport const alphaBetaSearch = (board, depth, alpha, beta, maximizingPlayer) => {\n  // 验证棋盘和深度\n  if (!board || !Array.isArray(board) || board.length !== 10 || depth < 0) {\n    return {\n      score: 0,\n      move: null\n    };\n  }\n\n  // 达到搜索深度或游戏结束\n  if (depth === 0) {\n    return {\n      score: evaluateBoard(board),\n      move: null\n    };\n  }\n  try {\n    const color = maximizingPlayer ? COLORS.RED : COLORS.BLACK;\n    const moves = generateAllMoves(board, color);\n\n    // 如果没有合法移动，可能是将军或和棋\n    if (!moves || moves.length === 0) {\n      try {\n        if (isCheck(board, color)) {\n          // 被将死，返回极低/极高分数\n          return {\n            score: maximizingPlayer ? -9999 : 9999,\n            move: null\n          };\n        }\n      } catch (error) {\n        console.error('Error checking isCheck in alphaBetaSearch:', error);\n      }\n      // 无子可动，和棋\n      return {\n        score: 0,\n        move: null\n      };\n    }\n    let bestMove = moves[0]; // 默认使用第一个移动\n\n    if (maximizingPlayer) {\n      let maxScore = -Infinity;\n      for (const move of moves) {\n        try {\n          // 应用移动\n          const newBoard = applyMove(board, move);\n\n          // 递归搜索\n          const {\n            score\n          } = alphaBetaSearch(newBoard, depth - 1, alpha, beta, false);\n          if (score > maxScore) {\n            maxScore = score;\n            bestMove = move;\n          }\n          alpha = Math.max(alpha, maxScore);\n          if (beta <= alpha) {\n            break; // Beta 剪枝\n          }\n        } catch (error) {\n          console.error('Error in alphaBetaSearch maximizing loop:', error);\n          continue;\n        }\n      }\n      return {\n        score: maxScore,\n        move: bestMove\n      };\n    } else {\n      let minScore = Infinity;\n      for (const move of moves) {\n        try {\n          // 应用移动\n          const newBoard = applyMove(board, move);\n\n          // 递归搜索\n          const {\n            score\n          } = alphaBetaSearch(newBoard, depth - 1, alpha, beta, true);\n          if (score < minScore) {\n            minScore = score;\n            bestMove = move;\n          }\n          beta = Math.min(beta, minScore);\n          if (beta <= alpha) {\n            break; // Alpha 剪枝\n          }\n        } catch (error) {\n          console.error('Error in alphaBetaSearch minimizing loop:', error);\n          continue;\n        }\n      }\n      return {\n        score: minScore,\n        move: bestMove\n      };\n    }\n  } catch (error) {\n    console.error('Error in alphaBetaSearch:', error);\n    return {\n      score: 0,\n      move: null\n    };\n  }\n};\n\n/**\n * 获取 AI 的最佳移动\n * @param {Array} board - 当前棋盘状态\n * @param {String} aiColor - AI 的颜色\n * @param {Number} difficulty - 难度级别（1-5，影响搜索深度）\n * @returns {Object} - 最佳移动 {fromRow, fromCol, toRow, toCol}\n */\nexport const getBestMove = (board, aiColor, difficulty = 3) => {\n  try {\n    // 验证输入\n    if (!board || !Array.isArray(board) || board.length !== 10) {\n      console.error('Invalid board in getBestMove');\n      return null;\n    }\n    if (!aiColor || aiColor !== COLORS.RED && aiColor !== COLORS.BLACK) {\n      console.error('Invalid aiColor in getBestMove:', aiColor);\n      return null;\n    }\n\n    // 生成当前所有合法移动\n    const availableMoves = generateAllMoves(board, aiColor);\n    if (!availableMoves || availableMoves.length === 0) {\n      console.log('No available moves for AI');\n      return null;\n    }\n\n    // 如果只有一个可用移动，直接返回\n    if (availableMoves.length === 1) {\n      return availableMoves[0];\n    }\n\n    // 根据难度设置搜索深度\n    const depth = Math.min(Math.max(1, difficulty), 5);\n\n    // 是否为最大化玩家\n    const maximizingPlayer = aiColor === COLORS.RED;\n\n    // 执行 Alpha-Beta 搜索\n    const result = alphaBetaSearch(board, depth, -Infinity, Infinity, maximizingPlayer);\n    return result.move;\n  } catch (error) {\n    console.error('Error in getBestMove:', error);\n\n    // 在出错时随机选择一个合法移动\n    try {\n      const availableMoves = generateAllMoves(board, aiColor);\n      if (availableMoves && availableMoves.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availableMoves.length);\n        return availableMoves[randomIndex];\n      }\n    } catch (fallbackError) {\n      console.error('Error in getBestMove fallback:', fallbackError);\n    }\n    return null;\n  }\n};","map":{"version":3,"names":["isValidMove","isCheck","COLORS","PIECE_TYPES","PIECE_VALUES","GENERAL","ADVISOR","ELEPHANT","HORSE","CHARIOT","CANNON","SOLDIER","POSITION_BONUSES","generateAllMoves","board","color","moves","Array","isArray","length","fromRow","fromCol","piece","toRow","toCol","tempBoard","JSON","parse","stringify","push","error","console","evaluateBoard","score","row","col","pieceValue","type","positionRow","RED","BLACK","applyMove","move","newBoard","map","alphaBetaSearch","depth","alpha","beta","maximizingPlayer","bestMove","maxScore","Infinity","Math","max","minScore","min","getBestMove","aiColor","difficulty","availableMoves","log","result","randomIndex","floor","random","fallbackError"],"sources":["/Users/peng/Desktop/人工智能策略/chinese-chess-game/client/src/utils/chessAI.js"],"sourcesContent":["/**\n * 中国象棋 AI 算法\n * 实现 Alpha-Beta 剪枝搜索\n */\nimport { isValidMove, isCheck, COLORS, PIECE_TYPES } from './chessRules';\n\n// 棋子价值表（基础分值）\nconst PIECE_VALUES = {\n  [PIECE_TYPES.GENERAL]: 10000,\n  [PIECE_TYPES.ADVISOR]: 200,\n  [PIECE_TYPES.ELEPHANT]: 200,\n  [PIECE_TYPES.HORSE]: 400,\n  [PIECE_TYPES.CHARIOT]: 900,\n  [PIECE_TYPES.CANNON]: 450,\n  [PIECE_TYPES.SOLDIER]: 100\n};\n\n// 位置加成表（根据棋子在棋盘上的位置给予额外分数）\nconst POSITION_BONUSES = {\n  // 兵/卒位置价值表\n  [PIECE_TYPES.SOLDIER]: [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [30, 40, 50, 60, 70, 60, 50, 40, 30],\n    [70, 80, 90, 100, 110, 100, 90, 80, 70],\n    [80, 90, 100, 110, 120, 110, 100, 90, 80],\n    [90, 100, 110, 120, 130, 120, 110, 100, 90],\n    [90, 100, 110, 120, 130, 120, 110, 100, 90],\n    [90, 100, 110, 120, 130, 120, 110, 100, 90],\n    [90, 100, 110, 120, 130, 120, 110, 100, 90]\n  ],\n  // 马位置价值表 \n  [PIECE_TYPES.HORSE]: [\n    [60, 70, 80, 90, 90, 90, 80, 70, 60],\n    [70, 80, 90, 100, 100, 100, 90, 80, 70],\n    [80, 90, 100, 110, 110, 110, 100, 90, 80],\n    [90, 100, 110, 120, 120, 120, 110, 100, 90],\n    [90, 100, 110, 120, 120, 120, 110, 100, 90],\n    [90, 100, 110, 120, 120, 120, 110, 100, 90],\n    [80, 90, 100, 110, 110, 110, 100, 90, 80],\n    [70, 80, 90, 100, 100, 100, 90, 80, 70],\n    [60, 70, 80, 90, 90, 90, 80, 70, 60],\n    [50, 60, 70, 80, 80, 80, 70, 60, 50]\n  ]\n};\n\n/**\n * 生成当前棋盘所有合法移动\n * @param {Array} board - 棋盘状态\n * @param {String} color - 当前行动方颜色\n * @returns {Array} - 所有合法移动 [{fromRow, fromCol, toRow, toCol}, ...]\n */\nexport const generateAllMoves = (board, color) => {\n  const moves = [];\n  \n  // 验证棋盘是否有效\n  if (!board || !Array.isArray(board) || board.length !== 10) {\n    return moves;\n  }\n  \n  for (let fromRow = 0; fromRow < 10; fromRow++) {\n    for (let fromCol = 0; fromCol < 9; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        // 尝试所有可能的目标位置\n        for (let toRow = 0; toRow < 10; toRow++) {\n          for (let toCol = 0; toCol < 9; toCol++) {\n            // 过滤掉明显无效的移动以提高效率\n            if (fromRow === toRow && fromCol === toCol) continue;\n            \n            try {\n              if (isValidMove(piece, board, fromRow, fromCol, toRow, toCol)) {\n                // 检查此移动是否会导致自己被将军\n                const tempBoard = JSON.parse(JSON.stringify(board));\n                tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n                tempBoard[fromRow][fromCol] = null;\n                \n                if (!isCheck(tempBoard, color)) {\n                  moves.push({ fromRow, fromCol, toRow, toCol });\n                }\n              }\n            } catch (error) {\n              console.error('Error in generateAllMoves:', error);\n              // 跳过有问题的移动\n              continue;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n/**\n * 对棋盘进行评估，计算局势分数\n * 正分表示红方有利，负分表示黑方有利\n * @param {Array} board - 棋盘状态\n * @returns {Number} - 评估分数\n */\nexport const evaluateBoard = (board) => {\n  let score = 0;\n  \n  // 检查棋盘是否有效\n  if (!board || !Array.isArray(board) || board.length !== 10) {\n    return 0;\n  }\n  \n  // 计算每个棋子的基础价值和位置加成\n  for (let row = 0; row < 10; row++) {\n    if (!Array.isArray(board[row]) || board[row].length !== 9) {\n      continue; // 跳过无效的行\n    }\n    \n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (!piece) continue;\n      \n      // 基础棋子价值\n      let pieceValue = PIECE_VALUES[piece.type] || 0;\n      \n      // 位置加成（如果定义了该棋子类型的位置加成表）\n      if (POSITION_BONUSES[piece.type]) {\n        // 黑方棋子需要翻转位置加成表\n        const positionRow = piece.color === COLORS.RED ? row : 9 - row;\n        if (positionRow >= 0 && positionRow < 10 && POSITION_BONUSES[piece.type][positionRow]) {\n          pieceValue += (POSITION_BONUSES[piece.type][positionRow][col] || 0);\n        }\n      }\n      \n      // 红方加分，黑方减分\n      score += piece.color === COLORS.RED ? pieceValue : -pieceValue;\n    }\n  }\n  \n  try {\n    // 检查将军状态，给予额外分数\n    if (isCheck(board, COLORS.BLACK)) {\n      score += 50; // 红方将军加分\n    }\n    if (isCheck(board, COLORS.RED)) {\n      score -= 50; // 黑方将军加分（红方减分）\n    }\n  } catch (error) {\n    console.error('Error checking isCheck in evaluateBoard:', error);\n  }\n  \n  return score;\n};\n\n/**\n * 应用移动到棋盘（不改变原棋盘）\n * @param {Array} board - 原棋盘\n * @param {Object} move - 移动 {fromRow, fromCol, toRow, toCol}\n * @returns {Array} - 移动后的新棋盘\n */\nexport const applyMove = (board, move) => {\n  try {\n    if (!board || !Array.isArray(board) || board.length !== 10) {\n      console.error('Invalid board in applyMove');\n      return board; // 返回原始棋盘\n    }\n    \n    if (!move || typeof move !== 'object') {\n      console.error('Invalid move in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n    \n    const { fromRow, fromCol, toRow, toCol } = move;\n    \n    // 验证移动坐标\n    if (\n      fromRow < 0 || fromRow >= 10 || fromCol < 0 || fromCol >= 9 ||\n      toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9\n    ) {\n      console.error('Invalid move coordinates in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n    \n    // 验证起始位置有棋子\n    if (!board[fromRow] || !board[fromRow][fromCol]) {\n      console.error('No piece at source position in applyMove:', move);\n      return board; // 返回原始棋盘\n    }\n    \n    // 创建新棋盘（深拷贝）\n    const newBoard = board.map(row => [...row]);\n    \n    // 执行移动\n    newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n    newBoard[fromRow][fromCol] = null;\n    \n    return newBoard;\n  } catch (error) {\n    console.error('Error in applyMove:', error);\n    return board; // 错误时返回原始棋盘\n  }\n};\n\n/**\n * Alpha-Beta 剪枝搜索算法\n * @param {Array} board - 当前棋盘状态\n * @param {Number} depth - 搜索深度\n * @param {Number} alpha - Alpha 值\n * @param {Number} beta - Beta 值\n * @param {Boolean} maximizingPlayer - 是否为最大化玩家（红方）\n * @returns {Object} - {score, move} 最佳分数和最佳移动\n */\nexport const alphaBetaSearch = (board, depth, alpha, beta, maximizingPlayer) => {\n  // 验证棋盘和深度\n  if (!board || !Array.isArray(board) || board.length !== 10 || depth < 0) {\n    return { score: 0, move: null };\n  }\n  \n  // 达到搜索深度或游戏结束\n  if (depth === 0) {\n    return { score: evaluateBoard(board), move: null };\n  }\n  \n  try {\n    const color = maximizingPlayer ? COLORS.RED : COLORS.BLACK;\n    const moves = generateAllMoves(board, color);\n    \n    // 如果没有合法移动，可能是将军或和棋\n    if (!moves || moves.length === 0) {\n      try {\n        if (isCheck(board, color)) {\n          // 被将死，返回极低/极高分数\n          return { \n            score: maximizingPlayer ? -9999 : 9999,\n            move: null\n          };\n        }\n      } catch (error) {\n        console.error('Error checking isCheck in alphaBetaSearch:', error);\n      }\n      // 无子可动，和棋\n      return { score: 0, move: null };\n    }\n    \n    let bestMove = moves[0]; // 默认使用第一个移动\n    \n    if (maximizingPlayer) {\n      let maxScore = -Infinity;\n      \n      for (const move of moves) {\n        try {\n          // 应用移动\n          const newBoard = applyMove(board, move);\n          \n          // 递归搜索\n          const { score } = alphaBetaSearch(newBoard, depth - 1, alpha, beta, false);\n          \n          if (score > maxScore) {\n            maxScore = score;\n            bestMove = move;\n          }\n          \n          alpha = Math.max(alpha, maxScore);\n          if (beta <= alpha) {\n            break; // Beta 剪枝\n          }\n        } catch (error) {\n          console.error('Error in alphaBetaSearch maximizing loop:', error);\n          continue;\n        }\n      }\n      \n      return { score: maxScore, move: bestMove };\n    } else {\n      let minScore = Infinity;\n      \n      for (const move of moves) {\n        try {\n          // 应用移动\n          const newBoard = applyMove(board, move);\n          \n          // 递归搜索\n          const { score } = alphaBetaSearch(newBoard, depth - 1, alpha, beta, true);\n          \n          if (score < minScore) {\n            minScore = score;\n            bestMove = move;\n          }\n          \n          beta = Math.min(beta, minScore);\n          if (beta <= alpha) {\n            break; // Alpha 剪枝\n          }\n        } catch (error) {\n          console.error('Error in alphaBetaSearch minimizing loop:', error);\n          continue;\n        }\n      }\n      \n      return { score: minScore, move: bestMove };\n    }\n  } catch (error) {\n    console.error('Error in alphaBetaSearch:', error);\n    return { score: 0, move: null };\n  }\n};\n\n/**\n * 获取 AI 的最佳移动\n * @param {Array} board - 当前棋盘状态\n * @param {String} aiColor - AI 的颜色\n * @param {Number} difficulty - 难度级别（1-5，影响搜索深度）\n * @returns {Object} - 最佳移动 {fromRow, fromCol, toRow, toCol}\n */\nexport const getBestMove = (board, aiColor, difficulty = 3) => {\n  try {\n    // 验证输入\n    if (!board || !Array.isArray(board) || board.length !== 10) {\n      console.error('Invalid board in getBestMove');\n      return null;\n    }\n    \n    if (!aiColor || (aiColor !== COLORS.RED && aiColor !== COLORS.BLACK)) {\n      console.error('Invalid aiColor in getBestMove:', aiColor);\n      return null;\n    }\n    \n    // 生成当前所有合法移动\n    const availableMoves = generateAllMoves(board, aiColor);\n    if (!availableMoves || availableMoves.length === 0) {\n      console.log('No available moves for AI');\n      return null;\n    }\n    \n    // 如果只有一个可用移动，直接返回\n    if (availableMoves.length === 1) {\n      return availableMoves[0];\n    }\n    \n    // 根据难度设置搜索深度\n    const depth = Math.min(Math.max(1, difficulty), 5);\n    \n    // 是否为最大化玩家\n    const maximizingPlayer = aiColor === COLORS.RED;\n    \n    // 执行 Alpha-Beta 搜索\n    const result = alphaBetaSearch(\n      board,\n      depth,\n      -Infinity,\n      Infinity,\n      maximizingPlayer\n    );\n    \n    return result.move;\n  } catch (error) {\n    console.error('Error in getBestMove:', error);\n    \n    // 在出错时随机选择一个合法移动\n    try {\n      const availableMoves = generateAllMoves(board, aiColor);\n      if (availableMoves && availableMoves.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availableMoves.length);\n        return availableMoves[randomIndex];\n      }\n    } catch (fallbackError) {\n      console.error('Error in getBestMove fallback:', fallbackError);\n    }\n    \n    return null;\n  }\n}; "],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,OAAO,EAAEC,MAAM,EAAEC,WAAW,QAAQ,cAAc;;AAExE;AACA,MAAMC,YAAY,GAAG;EACnB,CAACD,WAAW,CAACE,OAAO,GAAG,KAAK;EAC5B,CAACF,WAAW,CAACG,OAAO,GAAG,GAAG;EAC1B,CAACH,WAAW,CAACI,QAAQ,GAAG,GAAG;EAC3B,CAACJ,WAAW,CAACK,KAAK,GAAG,GAAG;EACxB,CAACL,WAAW,CAACM,OAAO,GAAG,GAAG;EAC1B,CAACN,WAAW,CAACO,MAAM,GAAG,GAAG;EACzB,CAACP,WAAW,CAACQ,OAAO,GAAG;AACzB,CAAC;;AAED;AACA,MAAMC,gBAAgB,GAAG;EACvB;EACA,CAACT,WAAW,CAACQ,OAAO,GAAG,CACrB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC3B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC3B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC3B,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACpC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACvC,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EACzC,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAC5C;EACD;EACA,CAACR,WAAW,CAACK,KAAK,GAAG,CACnB,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACpC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACvC,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EACzC,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EAC3C,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EACzC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACpC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;AAExC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;EAChD,MAAMC,KAAK,GAAG,EAAE;;EAEhB;EACA,IAAI,CAACF,KAAK,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,MAAM,KAAK,EAAE,EAAE;IAC1D,OAAOH,KAAK;EACd;EAEA,KAAK,IAAII,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,EAAE,EAAEA,OAAO,EAAE,EAAE;IAC7C,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,CAAC,EAAEA,OAAO,EAAE,EAAE;MAC5C,MAAMC,KAAK,GAAGR,KAAK,CAACM,OAAO,CAAC,CAACC,OAAO,CAAC;MACrC,IAAIC,KAAK,IAAIA,KAAK,CAACP,KAAK,KAAKA,KAAK,EAAE;QAClC;QACA,KAAK,IAAIQ,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,EAAE,EAAEA,KAAK,EAAE,EAAE;UACvC,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,EAAE,EAAE;YACtC;YACA,IAAIJ,OAAO,KAAKG,KAAK,IAAIF,OAAO,KAAKG,KAAK,EAAE;YAE5C,IAAI;cACF,IAAIxB,WAAW,CAACsB,KAAK,EAAER,KAAK,EAAEM,OAAO,EAAEC,OAAO,EAAEE,KAAK,EAAEC,KAAK,CAAC,EAAE;gBAC7D;gBACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACd,KAAK,CAAC,CAAC;gBACnDW,SAAS,CAACF,KAAK,CAAC,CAACC,KAAK,CAAC,GAAGC,SAAS,CAACL,OAAO,CAAC,CAACC,OAAO,CAAC;gBACrDI,SAAS,CAACL,OAAO,CAAC,CAACC,OAAO,CAAC,GAAG,IAAI;gBAElC,IAAI,CAACpB,OAAO,CAACwB,SAAS,EAAEV,KAAK,CAAC,EAAE;kBAC9BC,KAAK,CAACa,IAAI,CAAC;oBAAET,OAAO;oBAAEC,OAAO;oBAAEE,KAAK;oBAAEC;kBAAM,CAAC,CAAC;gBAChD;cACF;YACF,CAAC,CAAC,OAAOM,KAAK,EAAE;cACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;cAClD;cACA;YACF;UACF;QACF;MACF;IACF;EACF;EAEA,OAAOd,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMgB,aAAa,GAAIlB,KAAK,IAAK;EACtC,IAAImB,KAAK,GAAG,CAAC;;EAEb;EACA,IAAI,CAACnB,KAAK,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,MAAM,KAAK,EAAE,EAAE;IAC1D,OAAO,CAAC;EACV;;EAEA;EACA,KAAK,IAAIe,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,EAAE,EAAEA,GAAG,EAAE,EAAE;IACjC,IAAI,CAACjB,KAAK,CAACC,OAAO,CAACJ,KAAK,CAACoB,GAAG,CAAC,CAAC,IAAIpB,KAAK,CAACoB,GAAG,CAAC,CAACf,MAAM,KAAK,CAAC,EAAE;MACzD,SAAS,CAAC;IACZ;IAEA,KAAK,IAAIgB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,MAAMb,KAAK,GAAGR,KAAK,CAACoB,GAAG,CAAC,CAACC,GAAG,CAAC;MAC7B,IAAI,CAACb,KAAK,EAAE;;MAEZ;MACA,IAAIc,UAAU,GAAGhC,YAAY,CAACkB,KAAK,CAACe,IAAI,CAAC,IAAI,CAAC;;MAE9C;MACA,IAAIzB,gBAAgB,CAACU,KAAK,CAACe,IAAI,CAAC,EAAE;QAChC;QACA,MAAMC,WAAW,GAAGhB,KAAK,CAACP,KAAK,KAAKb,MAAM,CAACqC,GAAG,GAAGL,GAAG,GAAG,CAAC,GAAGA,GAAG;QAC9D,IAAII,WAAW,IAAI,CAAC,IAAIA,WAAW,GAAG,EAAE,IAAI1B,gBAAgB,CAACU,KAAK,CAACe,IAAI,CAAC,CAACC,WAAW,CAAC,EAAE;UACrFF,UAAU,IAAKxB,gBAAgB,CAACU,KAAK,CAACe,IAAI,CAAC,CAACC,WAAW,CAAC,CAACH,GAAG,CAAC,IAAI,CAAE;QACrE;MACF;;MAEA;MACAF,KAAK,IAAIX,KAAK,CAACP,KAAK,KAAKb,MAAM,CAACqC,GAAG,GAAGH,UAAU,GAAG,CAACA,UAAU;IAChE;EACF;EAEA,IAAI;IACF;IACA,IAAInC,OAAO,CAACa,KAAK,EAAEZ,MAAM,CAACsC,KAAK,CAAC,EAAE;MAChCP,KAAK,IAAI,EAAE,CAAC,CAAC;IACf;IACA,IAAIhC,OAAO,CAACa,KAAK,EAAEZ,MAAM,CAACqC,GAAG,CAAC,EAAE;MAC9BN,KAAK,IAAI,EAAE,CAAC,CAAC;IACf;EACF,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;EAClE;EAEA,OAAOG,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,SAAS,GAAGA,CAAC3B,KAAK,EAAE4B,IAAI,KAAK;EACxC,IAAI;IACF,IAAI,CAAC5B,KAAK,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,MAAM,KAAK,EAAE,EAAE;MAC1DY,OAAO,CAACD,KAAK,CAAC,4BAA4B,CAAC;MAC3C,OAAOhB,KAAK,CAAC,CAAC;IAChB;IAEA,IAAI,CAAC4B,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MACrCX,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEY,IAAI,CAAC;MACjD,OAAO5B,KAAK,CAAC,CAAC;IAChB;IAEA,MAAM;MAAEM,OAAO;MAAEC,OAAO;MAAEE,KAAK;MAAEC;IAAM,CAAC,GAAGkB,IAAI;;IAE/C;IACA,IACEtB,OAAO,GAAG,CAAC,IAAIA,OAAO,IAAI,EAAE,IAAIC,OAAO,GAAG,CAAC,IAAIA,OAAO,IAAI,CAAC,IAC3DE,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,EAAE,IAAIC,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,CAAC,EACnD;MACAO,OAAO,CAACD,KAAK,CAAC,wCAAwC,EAAEY,IAAI,CAAC;MAC7D,OAAO5B,KAAK,CAAC,CAAC;IAChB;;IAEA;IACA,IAAI,CAACA,KAAK,CAACM,OAAO,CAAC,IAAI,CAACN,KAAK,CAACM,OAAO,CAAC,CAACC,OAAO,CAAC,EAAE;MAC/CU,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEY,IAAI,CAAC;MAChE,OAAO5B,KAAK,CAAC,CAAC;IAChB;;IAEA;IACA,MAAM6B,QAAQ,GAAG7B,KAAK,CAAC8B,GAAG,CAACV,GAAG,IAAI,CAAC,GAAGA,GAAG,CAAC,CAAC;;IAE3C;IACAS,QAAQ,CAACpB,KAAK,CAAC,CAACC,KAAK,CAAC,GAAGmB,QAAQ,CAACvB,OAAO,CAAC,CAACC,OAAO,CAAC;IACnDsB,QAAQ,CAACvB,OAAO,CAAC,CAACC,OAAO,CAAC,GAAG,IAAI;IAEjC,OAAOsB,QAAQ;EACjB,CAAC,CAAC,OAAOb,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;IAC3C,OAAOhB,KAAK,CAAC,CAAC;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM+B,eAAe,GAAGA,CAAC/B,KAAK,EAAEgC,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAEC,gBAAgB,KAAK;EAC9E;EACA,IAAI,CAACnC,KAAK,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,MAAM,KAAK,EAAE,IAAI2B,KAAK,GAAG,CAAC,EAAE;IACvE,OAAO;MAAEb,KAAK,EAAE,CAAC;MAAES,IAAI,EAAE;IAAK,CAAC;EACjC;;EAEA;EACA,IAAII,KAAK,KAAK,CAAC,EAAE;IACf,OAAO;MAAEb,KAAK,EAAED,aAAa,CAAClB,KAAK,CAAC;MAAE4B,IAAI,EAAE;IAAK,CAAC;EACpD;EAEA,IAAI;IACF,MAAM3B,KAAK,GAAGkC,gBAAgB,GAAG/C,MAAM,CAACqC,GAAG,GAAGrC,MAAM,CAACsC,KAAK;IAC1D,MAAMxB,KAAK,GAAGH,gBAAgB,CAACC,KAAK,EAAEC,KAAK,CAAC;;IAE5C;IACA,IAAI,CAACC,KAAK,IAAIA,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MAChC,IAAI;QACF,IAAIlB,OAAO,CAACa,KAAK,EAAEC,KAAK,CAAC,EAAE;UACzB;UACA,OAAO;YACLkB,KAAK,EAAEgB,gBAAgB,GAAG,CAAC,IAAI,GAAG,IAAI;YACtCP,IAAI,EAAE;UACR,CAAC;QACH;MACF,CAAC,CAAC,OAAOZ,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MACpE;MACA;MACA,OAAO;QAAEG,KAAK,EAAE,CAAC;QAAES,IAAI,EAAE;MAAK,CAAC;IACjC;IAEA,IAAIQ,QAAQ,GAAGlC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEzB,IAAIiC,gBAAgB,EAAE;MACpB,IAAIE,QAAQ,GAAG,CAACC,QAAQ;MAExB,KAAK,MAAMV,IAAI,IAAI1B,KAAK,EAAE;QACxB,IAAI;UACF;UACA,MAAM2B,QAAQ,GAAGF,SAAS,CAAC3B,KAAK,EAAE4B,IAAI,CAAC;;UAEvC;UACA,MAAM;YAAET;UAAM,CAAC,GAAGY,eAAe,CAACF,QAAQ,EAAEG,KAAK,GAAG,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,KAAK,CAAC;UAE1E,IAAIf,KAAK,GAAGkB,QAAQ,EAAE;YACpBA,QAAQ,GAAGlB,KAAK;YAChBiB,QAAQ,GAAGR,IAAI;UACjB;UAEAK,KAAK,GAAGM,IAAI,CAACC,GAAG,CAACP,KAAK,EAAEI,QAAQ,CAAC;UACjC,IAAIH,IAAI,IAAID,KAAK,EAAE;YACjB,MAAM,CAAC;UACT;QACF,CAAC,CAAC,OAAOjB,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;UACjE;QACF;MACF;MAEA,OAAO;QAAEG,KAAK,EAAEkB,QAAQ;QAAET,IAAI,EAAEQ;MAAS,CAAC;IAC5C,CAAC,MAAM;MACL,IAAIK,QAAQ,GAAGH,QAAQ;MAEvB,KAAK,MAAMV,IAAI,IAAI1B,KAAK,EAAE;QACxB,IAAI;UACF;UACA,MAAM2B,QAAQ,GAAGF,SAAS,CAAC3B,KAAK,EAAE4B,IAAI,CAAC;;UAEvC;UACA,MAAM;YAAET;UAAM,CAAC,GAAGY,eAAe,CAACF,QAAQ,EAAEG,KAAK,GAAG,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,IAAI,CAAC;UAEzE,IAAIf,KAAK,GAAGsB,QAAQ,EAAE;YACpBA,QAAQ,GAAGtB,KAAK;YAChBiB,QAAQ,GAAGR,IAAI;UACjB;UAEAM,IAAI,GAAGK,IAAI,CAACG,GAAG,CAACR,IAAI,EAAEO,QAAQ,CAAC;UAC/B,IAAIP,IAAI,IAAID,KAAK,EAAE;YACjB,MAAM,CAAC;UACT;QACF,CAAC,CAAC,OAAOjB,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;UACjE;QACF;MACF;MAEA,OAAO;QAAEG,KAAK,EAAEsB,QAAQ;QAAEb,IAAI,EAAEQ;MAAS,CAAC;IAC5C;EACF,CAAC,CAAC,OAAOpB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,OAAO;MAAEG,KAAK,EAAE,CAAC;MAAES,IAAI,EAAE;IAAK,CAAC;EACjC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMe,WAAW,GAAGA,CAAC3C,KAAK,EAAE4C,OAAO,EAAEC,UAAU,GAAG,CAAC,KAAK;EAC7D,IAAI;IACF;IACA,IAAI,CAAC7C,KAAK,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,MAAM,KAAK,EAAE,EAAE;MAC1DY,OAAO,CAACD,KAAK,CAAC,8BAA8B,CAAC;MAC7C,OAAO,IAAI;IACb;IAEA,IAAI,CAAC4B,OAAO,IAAKA,OAAO,KAAKxD,MAAM,CAACqC,GAAG,IAAImB,OAAO,KAAKxD,MAAM,CAACsC,KAAM,EAAE;MACpET,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAE4B,OAAO,CAAC;MACzD,OAAO,IAAI;IACb;;IAEA;IACA,MAAME,cAAc,GAAG/C,gBAAgB,CAACC,KAAK,EAAE4C,OAAO,CAAC;IACvD,IAAI,CAACE,cAAc,IAAIA,cAAc,CAACzC,MAAM,KAAK,CAAC,EAAE;MAClDY,OAAO,CAAC8B,GAAG,CAAC,2BAA2B,CAAC;MACxC,OAAO,IAAI;IACb;;IAEA;IACA,IAAID,cAAc,CAACzC,MAAM,KAAK,CAAC,EAAE;MAC/B,OAAOyC,cAAc,CAAC,CAAC,CAAC;IAC1B;;IAEA;IACA,MAAMd,KAAK,GAAGO,IAAI,CAACG,GAAG,CAACH,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEK,UAAU,CAAC,EAAE,CAAC,CAAC;;IAElD;IACA,MAAMV,gBAAgB,GAAGS,OAAO,KAAKxD,MAAM,CAACqC,GAAG;;IAE/C;IACA,MAAMuB,MAAM,GAAGjB,eAAe,CAC5B/B,KAAK,EACLgC,KAAK,EACL,CAACM,QAAQ,EACTA,QAAQ,EACRH,gBACF,CAAC;IAED,OAAOa,MAAM,CAACpB,IAAI;EACpB,CAAC,CAAC,OAAOZ,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;;IAE7C;IACA,IAAI;MACF,MAAM8B,cAAc,GAAG/C,gBAAgB,CAACC,KAAK,EAAE4C,OAAO,CAAC;MACvD,IAAIE,cAAc,IAAIA,cAAc,CAACzC,MAAM,GAAG,CAAC,EAAE;QAC/C,MAAM4C,WAAW,GAAGV,IAAI,CAACW,KAAK,CAACX,IAAI,CAACY,MAAM,CAAC,CAAC,GAAGL,cAAc,CAACzC,MAAM,CAAC;QACrE,OAAOyC,cAAc,CAACG,WAAW,CAAC;MACpC;IACF,CAAC,CAAC,OAAOG,aAAa,EAAE;MACtBnC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEoC,aAAa,CAAC;IAChE;IAEA,OAAO,IAAI;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}