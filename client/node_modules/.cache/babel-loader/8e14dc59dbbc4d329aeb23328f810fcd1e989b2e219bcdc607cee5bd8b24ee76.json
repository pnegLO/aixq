{"ast":null,"code":"/**\n * 中国象棋规则工具函数\n */\n\n// 棋子类型常量\nexport const PIECE_TYPES = {\n  GENERAL: 'general',\n  // 将/帅\n  ADVISOR: 'advisor',\n  // 士/仕\n  ELEPHANT: 'elephant',\n  // 象/相\n  HORSE: 'horse',\n  // 马\n  CHARIOT: 'chariot',\n  // 车\n  CANNON: 'cannon',\n  // 炮\n  SOLDIER: 'soldier' // 兵/卒\n};\n\n// 棋子颜色常量\nexport const COLORS = {\n  RED: 'red',\n  BLACK: 'black'\n};\n\n/**\n * 检查移动是否有效\n * @param {Object} piece - 棋子对象\n * @param {Array} board - 棋盘状态\n * @param {Number} fromRow - 起始行\n * @param {Number} fromCol - 起始列\n * @param {Number} toRow - 目标行\n * @param {Number} toCol - 目标列\n * @returns {Boolean} - 移动是否有效\n */\nexport const isValidMove = (piece, board, fromRow, fromCol, toRow, toCol) => {\n  // 检查坐标是否越界\n  if (fromRow < 0 || fromRow >= 10 || fromCol < 0 || fromCol >= 9 || toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9) {\n    return false;\n  }\n\n  // 起始位置和目标位置相同\n  if (fromRow === toRow && fromCol === toCol) {\n    return false;\n  }\n\n  // 确保起始位置有棋子\n  if (!piece) {\n    return false;\n  }\n\n  // 目标位置已经有己方棋子\n  if (board[toRow][toCol] && board[toRow][toCol].color === piece.color) {\n    return false;\n  }\n\n  // 根据不同棋子类型验证移动\n  switch (piece.type) {\n    case PIECE_TYPES.GENERAL:\n      return isValidGeneralMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.ADVISOR:\n      return isValidAdvisorMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.ELEPHANT:\n      return isValidElephantMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.HORSE:\n      return isValidHorseMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.CHARIOT:\n      return isValidChariotMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.CANNON:\n      return isValidCannonMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.SOLDIER:\n      return isValidSoldierMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    default:\n      return false;\n  }\n};\n\n/**\n * 检查将/帅移动是否有效\n */\nconst isValidGeneralMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 将/帅只能在九宫格内移动\n  const isInPalace = color === COLORS.RED ? toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5 // 红方九宫\n  : toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5; // 黑方九宫\n\n  if (!isInPalace) return false;\n\n  // 将/帅每次只能移动一格，且只能横向或纵向移动\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  return rowDiff === 1 && colDiff === 0 || rowDiff === 0 && colDiff === 1;\n};\n\n/**\n * 检查士/仕移动是否有效\n */\nconst isValidAdvisorMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 士/仕只能在九宫格内移动\n  const isInPalace = color === COLORS.RED ? toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5 // 红方九宫\n  : toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5; // 黑方九宫\n\n  if (!isInPalace) return false;\n\n  // 士/仕每次只能斜着移动一格\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  return rowDiff === 1 && colDiff === 1;\n};\n\n/**\n * 检查象/相移动是否有效\n */\nconst isValidElephantMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 象/相不能过河\n  const cannotCrossRiver = color === COLORS.RED ? toRow < 5 // 红方象不能过河\n  : toRow > 4; // 黑方相不能过河\n\n  if (cannotCrossRiver) return false;\n\n  // 象/相每次斜着走两格\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  if (rowDiff !== 2 || colDiff !== 2) return false;\n\n  // 象眼被塞住不能走\n  const eyeRow = (fromRow + toRow) / 2;\n  const eyeCol = (fromCol + toCol) / 2;\n  return !board[eyeRow][eyeCol]; // 象眼位置无子，可以移动\n};\n\n/**\n * 检查马移动是否有效\n */\nconst isValidHorseMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n\n  // 马走\"日\"字\n  if (!(rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2)) {\n    return false;\n  }\n\n  // 检查马腿是否被绊住\n  let legRow = fromRow;\n  let legCol = fromCol;\n  if (rowDiff === 2) {\n    // 向上或向下跳的马，检查竖向的马腿\n    legRow = fromRow + (toRow > fromRow ? 1 : -1);\n  } else {\n    // 向左或向右跳的马，检查横向的马腿\n    legCol = fromCol + (toCol > fromCol ? 1 : -1);\n  }\n  return !board[legRow][legCol]; // 马腿位置无子，可以移动\n};\n\n/**\n * 检查车移动是否有效\n */\nconst isValidChariotMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // 车只能横向或纵向移动\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n\n  // 检查路径上是否有障碍物\n  if (fromRow === toRow) {\n    // 横向移动\n    const minCol = Math.min(fromCol, toCol);\n    const maxCol = Math.max(fromCol, toCol);\n    for (let col = minCol + 1; col < maxCol; col++) {\n      if (board[fromRow][col]) {\n        return false; // 路径上有障碍物\n      }\n    }\n  } else {\n    // 纵向移动\n    const minRow = Math.min(fromRow, toRow);\n    const maxRow = Math.max(fromRow, toRow);\n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][fromCol]) {\n        return false; // 路径上有障碍物\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * 检查炮移动是否有效\n */\nconst isValidCannonMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // 炮只能横向或纵向移动\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n  let pieceCount = 0; // 路径上的棋子数量\n\n  if (fromRow === toRow) {\n    // 横向移动\n    const minCol = Math.min(fromCol, toCol);\n    const maxCol = Math.max(fromCol, toCol);\n    for (let col = minCol + 1; col < maxCol; col++) {\n      if (board[fromRow][col]) {\n        pieceCount++;\n      }\n    }\n  } else {\n    // 纵向移动\n    const minRow = Math.min(fromRow, toRow);\n    const maxRow = Math.max(fromRow, toRow);\n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][fromCol]) {\n        pieceCount++;\n      }\n    }\n  }\n\n  // 目标位置有对方棋子时，炮需要翻越一个棋子\n  if (board[toRow][toCol]) {\n    return pieceCount === 1;\n  }\n\n  // 目标位置为空时，炮不能翻越任何棋子\n  return pieceCount === 0;\n};\n\n/**\n * 检查兵/卒移动是否有效\n */\nconst isValidSoldierMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  const rowDiff = toRow - fromRow;\n  const colDiff = Math.abs(toCol - fromCol);\n\n  // 兵/卒每次只能移动一格\n  if (colDiff > 1 || Math.abs(rowDiff) > 1 || colDiff === 1 && rowDiff !== 0) {\n    return false;\n  }\n  if (color === COLORS.RED) {\n    // 红方兵\n    if (fromRow >= 5) {\n      // 未过河，只能向前移动\n      return rowDiff === -1 && colDiff === 0;\n    } else {\n      // 已过河，可以向前或向左右移动\n      return rowDiff === -1 || rowDiff === 0 && colDiff === 1;\n    }\n  } else {\n    // 黑方卒\n    if (fromRow <= 4) {\n      // 未过河，只能向前移动\n      return rowDiff === 1 && colDiff === 0;\n    } else {\n      // 已过河，可以向前或向左右移动\n      return rowDiff === 1 || rowDiff === 0 && colDiff === 1;\n    }\n  }\n};\n\n/**\n * 检查将军状态\n * @param {Array} board - 棋盘状态\n * @param {String} kingColor - 被将军的将/帅颜色\n * @returns {Boolean} - 是否被将军\n */\nexport const isCheck = (board, kingColor) => {\n  // 找到将/帅的位置\n  let kingRow = -1;\n  let kingCol = -1;\n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === PIECE_TYPES.GENERAL && piece.color === kingColor) {\n        kingRow = row;\n        kingCol = col;\n        break;\n      }\n    }\n    if (kingRow !== -1) break;\n  }\n\n  // 如果找不到将/帅，返回false\n  if (kingRow === -1 || kingCol === -1) {\n    return false;\n  }\n\n  // 检查所有对方棋子是否可以吃掉将/帅\n  const opponentColor = kingColor === COLORS.RED ? COLORS.BLACK : COLORS.RED;\n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === opponentColor) {\n        if (isValidMove(piece, board, row, col, kingRow, kingCol)) {\n          return true; // 被将军\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * 检查将帅是否面对面（长将情况）\n */\nexport const isGeneralsFacing = board => {\n  let redGeneralCol = -1;\n  let blackGeneralCol = -1;\n  let redGeneralRow = -1;\n  let blackGeneralRow = -1;\n\n  // 找到两方将帅的位置\n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === PIECE_TYPES.GENERAL) {\n        if (piece.color === COLORS.RED) {\n          redGeneralRow = row;\n          redGeneralCol = col;\n        } else {\n          blackGeneralRow = row;\n          blackGeneralCol = col;\n        }\n      }\n    }\n  }\n\n  // 如果任一方将帅不存在，返回false\n  if (redGeneralRow === -1 || blackGeneralRow === -1) {\n    return false;\n  }\n\n  // 检查是否在同一列\n  if (redGeneralCol === blackGeneralCol) {\n    // 确定上下位置关系\n    const minRow = Math.min(redGeneralRow, blackGeneralRow);\n    const maxRow = Math.max(redGeneralRow, blackGeneralRow);\n\n    // 检查两将之间是否有其他棋子\n    let hasPieceBetween = false;\n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][redGeneralCol]) {\n        hasPieceBetween = true;\n        break;\n      }\n    }\n    return !hasPieceBetween; // 如果中间没有棋子，则将帅对面\n  }\n  return false;\n};\n\n/**\n * 初始化棋盘\n * @returns {Array} - 初始棋盘状态\n */\nexport const initializeBoard = () => {\n  const board = Array(10).fill().map(() => Array(9).fill(null));\n\n  // 红方（下方）\n  board[9][0] = {\n    type: PIECE_TYPES.CHARIOT,\n    color: COLORS.RED\n  };\n  board[9][1] = {\n    type: PIECE_TYPES.HORSE,\n    color: COLORS.RED\n  };\n  board[9][2] = {\n    type: PIECE_TYPES.ELEPHANT,\n    color: COLORS.RED\n  };\n  board[9][3] = {\n    type: PIECE_TYPES.ADVISOR,\n    color: COLORS.RED\n  };\n  board[9][4] = {\n    type: PIECE_TYPES.GENERAL,\n    color: COLORS.RED\n  };\n  board[9][5] = {\n    type: PIECE_TYPES.ADVISOR,\n    color: COLORS.RED\n  };\n  board[9][6] = {\n    type: PIECE_TYPES.ELEPHANT,\n    color: COLORS.RED\n  };\n  board[9][7] = {\n    type: PIECE_TYPES.HORSE,\n    color: COLORS.RED\n  };\n  board[9][8] = {\n    type: PIECE_TYPES.CHARIOT,\n    color: COLORS.RED\n  };\n  board[7][1] = {\n    type: PIECE_TYPES.CANNON,\n    color: COLORS.RED\n  };\n  board[7][7] = {\n    type: PIECE_TYPES.CANNON,\n    color: COLORS.RED\n  };\n  board[6][0] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.RED\n  };\n  board[6][2] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.RED\n  };\n  board[6][4] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.RED\n  };\n  board[6][6] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.RED\n  };\n  board[6][8] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.RED\n  };\n\n  // 黑方（上方）\n  board[0][0] = {\n    type: PIECE_TYPES.CHARIOT,\n    color: COLORS.BLACK\n  };\n  board[0][1] = {\n    type: PIECE_TYPES.HORSE,\n    color: COLORS.BLACK\n  };\n  board[0][2] = {\n    type: PIECE_TYPES.ELEPHANT,\n    color: COLORS.BLACK\n  };\n  board[0][3] = {\n    type: PIECE_TYPES.ADVISOR,\n    color: COLORS.BLACK\n  };\n  board[0][4] = {\n    type: PIECE_TYPES.GENERAL,\n    color: COLORS.BLACK\n  };\n  board[0][5] = {\n    type: PIECE_TYPES.ADVISOR,\n    color: COLORS.BLACK\n  };\n  board[0][6] = {\n    type: PIECE_TYPES.ELEPHANT,\n    color: COLORS.BLACK\n  };\n  board[0][7] = {\n    type: PIECE_TYPES.HORSE,\n    color: COLORS.BLACK\n  };\n  board[0][8] = {\n    type: PIECE_TYPES.CHARIOT,\n    color: COLORS.BLACK\n  };\n  board[2][1] = {\n    type: PIECE_TYPES.CANNON,\n    color: COLORS.BLACK\n  };\n  board[2][7] = {\n    type: PIECE_TYPES.CANNON,\n    color: COLORS.BLACK\n  };\n  board[3][0] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.BLACK\n  };\n  board[3][2] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.BLACK\n  };\n  board[3][4] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.BLACK\n  };\n  board[3][6] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.BLACK\n  };\n  board[3][8] = {\n    type: PIECE_TYPES.SOLDIER,\n    color: COLORS.BLACK\n  };\n  return board;\n};\n\n/**\n * 检查游戏是否结束\n * @param {Array} board - 棋盘状态\n * @param {String} currentTurn - 当前回合的颜色\n * @returns {Object} - { isGameOver, winner }\n */\nexport const checkGameEnd = (board, currentTurn) => {\n  const opponentColor = currentTurn === COLORS.RED ? COLORS.BLACK : COLORS.RED;\n\n  // 检查对方是否被将军\n  if (isCheck(board, opponentColor)) {\n    // 检查对方是否有合法移动可解除将军\n    for (let fromRow = 0; fromRow < 10; fromRow++) {\n      for (let fromCol = 0; fromCol < 9; fromCol++) {\n        const piece = board[fromRow][fromCol];\n        if (piece && piece.color === opponentColor) {\n          // 尝试该棋子的所有可能移动\n          for (let toRow = 0; toRow < 10; toRow++) {\n            for (let toCol = 0; toCol < 9; toCol++) {\n              if (isValidMove(piece, board, fromRow, fromCol, toRow, toCol)) {\n                // 创建临时棋盘（深拷贝）\n                const tempBoard = JSON.parse(JSON.stringify(board));\n\n                // 在临时棋盘上模拟移动\n                tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n                tempBoard[fromRow][fromCol] = null;\n\n                // 检查移动后是否仍被将军\n                const stillInCheck = isCheck(tempBoard, opponentColor);\n                if (!stillInCheck) {\n                  // 有解除将军的移动，游戏继续\n                  return {\n                    isGameOver: false,\n                    winner: null\n                  };\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // 无法解除将军，游戏结束，当前玩家胜利\n    return {\n      isGameOver: true,\n      winner: currentTurn\n    };\n  }\n  return {\n    isGameOver: false,\n    winner: null\n  };\n};","map":{"version":3,"names":["PIECE_TYPES","GENERAL","ADVISOR","ELEPHANT","HORSE","CHARIOT","CANNON","SOLDIER","COLORS","RED","BLACK","isValidMove","piece","board","fromRow","fromCol","toRow","toCol","color","type","isValidGeneralMove","isValidAdvisorMove","isValidElephantMove","isValidHorseMove","isValidChariotMove","isValidCannonMove","isValidSoldierMove","isInPalace","rowDiff","Math","abs","colDiff","cannotCrossRiver","eyeRow","eyeCol","legRow","legCol","minCol","min","maxCol","max","col","minRow","maxRow","row","pieceCount","isCheck","kingColor","kingRow","kingCol","opponentColor","isGeneralsFacing","redGeneralCol","blackGeneralCol","redGeneralRow","blackGeneralRow","hasPieceBetween","initializeBoard","Array","fill","map","checkGameEnd","currentTurn","tempBoard","JSON","parse","stringify","stillInCheck","isGameOver","winner"],"sources":["/Users/peng/Desktop/人工智能策略/chinese-chess-game/client/src/utils/chessRules.js"],"sourcesContent":["/**\n * 中国象棋规则工具函数\n */\n\n// 棋子类型常量\nexport const PIECE_TYPES = {\n  GENERAL: 'general',  // 将/帅\n  ADVISOR: 'advisor',  // 士/仕\n  ELEPHANT: 'elephant', // 象/相\n  HORSE: 'horse',     // 马\n  CHARIOT: 'chariot',  // 车\n  CANNON: 'cannon',    // 炮\n  SOLDIER: 'soldier'   // 兵/卒\n};\n\n// 棋子颜色常量\nexport const COLORS = {\n  RED: 'red',\n  BLACK: 'black'\n};\n\n/**\n * 检查移动是否有效\n * @param {Object} piece - 棋子对象\n * @param {Array} board - 棋盘状态\n * @param {Number} fromRow - 起始行\n * @param {Number} fromCol - 起始列\n * @param {Number} toRow - 目标行\n * @param {Number} toCol - 目标列\n * @returns {Boolean} - 移动是否有效\n */\nexport const isValidMove = (piece, board, fromRow, fromCol, toRow, toCol) => {\n  // 检查坐标是否越界\n  if (fromRow < 0 || fromRow >= 10 || fromCol < 0 || fromCol >= 9 ||\n      toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9) {\n    return false;\n  }\n  \n  // 起始位置和目标位置相同\n  if (fromRow === toRow && fromCol === toCol) {\n    return false;\n  }\n  \n  // 确保起始位置有棋子\n  if (!piece) {\n    return false;\n  }\n  \n  // 目标位置已经有己方棋子\n  if (board[toRow][toCol] && board[toRow][toCol].color === piece.color) {\n    return false;\n  }\n\n  // 根据不同棋子类型验证移动\n  switch (piece.type) {\n    case PIECE_TYPES.GENERAL:\n      return isValidGeneralMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.ADVISOR:\n      return isValidAdvisorMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.ELEPHANT:\n      return isValidElephantMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    case PIECE_TYPES.HORSE:\n      return isValidHorseMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.CHARIOT:\n      return isValidChariotMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.CANNON:\n      return isValidCannonMove(board, fromRow, fromCol, toRow, toCol);\n    case PIECE_TYPES.SOLDIER:\n      return isValidSoldierMove(board, fromRow, fromCol, toRow, toCol, piece.color);\n    default:\n      return false;\n  }\n};\n\n/**\n * 检查将/帅移动是否有效\n */\nconst isValidGeneralMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 将/帅只能在九宫格内移动\n  const isInPalace = color === COLORS.RED\n    ? toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5  // 红方九宫\n    : toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5; // 黑方九宫\n  \n  if (!isInPalace) return false;\n\n  // 将/帅每次只能移动一格，且只能横向或纵向移动\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);\n};\n\n/**\n * 检查士/仕移动是否有效\n */\nconst isValidAdvisorMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 士/仕只能在九宫格内移动\n  const isInPalace = color === COLORS.RED\n    ? toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5  // 红方九宫\n    : toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5; // 黑方九宫\n  \n  if (!isInPalace) return false;\n\n  // 士/仕每次只能斜着移动一格\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  return rowDiff === 1 && colDiff === 1;\n};\n\n/**\n * 检查象/相移动是否有效\n */\nconst isValidElephantMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // 象/相不能过河\n  const cannotCrossRiver = color === COLORS.RED\n    ? toRow < 5  // 红方象不能过河\n    : toRow > 4; // 黑方相不能过河\n  \n  if (cannotCrossRiver) return false;\n\n  // 象/相每次斜着走两格\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  if (rowDiff !== 2 || colDiff !== 2) return false;\n\n  // 象眼被塞住不能走\n  const eyeRow = (fromRow + toRow) / 2;\n  const eyeCol = (fromCol + toCol) / 2;\n  \n  return !board[eyeRow][eyeCol]; // 象眼位置无子，可以移动\n};\n\n/**\n * 检查马移动是否有效\n */\nconst isValidHorseMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  // 马走\"日\"字\n  if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) {\n    return false;\n  }\n\n  // 检查马腿是否被绊住\n  let legRow = fromRow;\n  let legCol = fromCol;\n  \n  if (rowDiff === 2) {\n    // 向上或向下跳的马，检查竖向的马腿\n    legRow = fromRow + (toRow > fromRow ? 1 : -1);\n  } else {\n    // 向左或向右跳的马，检查横向的马腿\n    legCol = fromCol + (toCol > fromCol ? 1 : -1);\n  }\n  \n  return !board[legRow][legCol]; // 马腿位置无子，可以移动\n};\n\n/**\n * 检查车移动是否有效\n */\nconst isValidChariotMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // 车只能横向或纵向移动\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n  \n  // 检查路径上是否有障碍物\n  if (fromRow === toRow) {\n    // 横向移动\n    const minCol = Math.min(fromCol, toCol);\n    const maxCol = Math.max(fromCol, toCol);\n    \n    for (let col = minCol + 1; col < maxCol; col++) {\n      if (board[fromRow][col]) {\n        return false; // 路径上有障碍物\n      }\n    }\n  } else {\n    // 纵向移动\n    const minRow = Math.min(fromRow, toRow);\n    const maxRow = Math.max(fromRow, toRow);\n    \n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][fromCol]) {\n        return false; // 路径上有障碍物\n      }\n    }\n  }\n  \n  return true;\n};\n\n/**\n * 检查炮移动是否有效\n */\nconst isValidCannonMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // 炮只能横向或纵向移动\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n  \n  let pieceCount = 0; // 路径上的棋子数量\n  \n  if (fromRow === toRow) {\n    // 横向移动\n    const minCol = Math.min(fromCol, toCol);\n    const maxCol = Math.max(fromCol, toCol);\n    \n    for (let col = minCol + 1; col < maxCol; col++) {\n      if (board[fromRow][col]) {\n        pieceCount++;\n      }\n    }\n  } else {\n    // 纵向移动\n    const minRow = Math.min(fromRow, toRow);\n    const maxRow = Math.max(fromRow, toRow);\n    \n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][fromCol]) {\n        pieceCount++;\n      }\n    }\n  }\n  \n  // 目标位置有对方棋子时，炮需要翻越一个棋子\n  if (board[toRow][toCol]) {\n    return pieceCount === 1;\n  }\n  \n  // 目标位置为空时，炮不能翻越任何棋子\n  return pieceCount === 0;\n};\n\n/**\n * 检查兵/卒移动是否有效\n */\nconst isValidSoldierMove = (board, fromRow, fromCol, toRow, toCol, color) => {\n  const rowDiff = toRow - fromRow;\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  // 兵/卒每次只能移动一格\n  if (colDiff > 1 || Math.abs(rowDiff) > 1 || (colDiff === 1 && rowDiff !== 0)) {\n    return false;\n  }\n  \n  if (color === COLORS.RED) {\n    // 红方兵\n    if (fromRow >= 5) {\n      // 未过河，只能向前移动\n      return rowDiff === -1 && colDiff === 0;\n    } else {\n      // 已过河，可以向前或向左右移动\n      return rowDiff === -1 || (rowDiff === 0 && colDiff === 1);\n    }\n  } else {\n    // 黑方卒\n    if (fromRow <= 4) {\n      // 未过河，只能向前移动\n      return rowDiff === 1 && colDiff === 0;\n    } else {\n      // 已过河，可以向前或向左右移动\n      return rowDiff === 1 || (rowDiff === 0 && colDiff === 1);\n    }\n  }\n};\n\n/**\n * 检查将军状态\n * @param {Array} board - 棋盘状态\n * @param {String} kingColor - 被将军的将/帅颜色\n * @returns {Boolean} - 是否被将军\n */\nexport const isCheck = (board, kingColor) => {\n  // 找到将/帅的位置\n  let kingRow = -1;\n  let kingCol = -1;\n  \n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === PIECE_TYPES.GENERAL && piece.color === kingColor) {\n        kingRow = row;\n        kingCol = col;\n        break;\n      }\n    }\n    if (kingRow !== -1) break;\n  }\n  \n  // 如果找不到将/帅，返回false\n  if (kingRow === -1 || kingCol === -1) {\n    return false;\n  }\n  \n  // 检查所有对方棋子是否可以吃掉将/帅\n  const opponentColor = kingColor === COLORS.RED ? COLORS.BLACK : COLORS.RED;\n  \n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === opponentColor) {\n        if (isValidMove(piece, board, row, col, kingRow, kingCol)) {\n          return true; // 被将军\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n/**\n * 检查将帅是否面对面（长将情况）\n */\nexport const isGeneralsFacing = (board) => {\n  let redGeneralCol = -1;\n  let blackGeneralCol = -1;\n  let redGeneralRow = -1;\n  let blackGeneralRow = -1;\n  \n  // 找到两方将帅的位置\n  for (let row = 0; row < 10; row++) {\n    for (let col = 0; col < 9; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === PIECE_TYPES.GENERAL) {\n        if (piece.color === COLORS.RED) {\n          redGeneralRow = row;\n          redGeneralCol = col;\n        } else {\n          blackGeneralRow = row;\n          blackGeneralCol = col;\n        }\n      }\n    }\n  }\n  \n  // 如果任一方将帅不存在，返回false\n  if (redGeneralRow === -1 || blackGeneralRow === -1) {\n    return false;\n  }\n  \n  // 检查是否在同一列\n  if (redGeneralCol === blackGeneralCol) {\n    // 确定上下位置关系\n    const minRow = Math.min(redGeneralRow, blackGeneralRow);\n    const maxRow = Math.max(redGeneralRow, blackGeneralRow);\n    \n    // 检查两将之间是否有其他棋子\n    let hasPieceBetween = false;\n    for (let row = minRow + 1; row < maxRow; row++) {\n      if (board[row][redGeneralCol]) {\n        hasPieceBetween = true;\n        break;\n      }\n    }\n    \n    return !hasPieceBetween; // 如果中间没有棋子，则将帅对面\n  }\n  \n  return false;\n};\n\n/**\n * 初始化棋盘\n * @returns {Array} - 初始棋盘状态\n */\nexport const initializeBoard = () => {\n  const board = Array(10).fill().map(() => Array(9).fill(null));\n  \n  // 红方（下方）\n  board[9][0] = { type: PIECE_TYPES.CHARIOT, color: COLORS.RED };\n  board[9][1] = { type: PIECE_TYPES.HORSE, color: COLORS.RED };\n  board[9][2] = { type: PIECE_TYPES.ELEPHANT, color: COLORS.RED };\n  board[9][3] = { type: PIECE_TYPES.ADVISOR, color: COLORS.RED };\n  board[9][4] = { type: PIECE_TYPES.GENERAL, color: COLORS.RED };\n  board[9][5] = { type: PIECE_TYPES.ADVISOR, color: COLORS.RED };\n  board[9][6] = { type: PIECE_TYPES.ELEPHANT, color: COLORS.RED };\n  board[9][7] = { type: PIECE_TYPES.HORSE, color: COLORS.RED };\n  board[9][8] = { type: PIECE_TYPES.CHARIOT, color: COLORS.RED };\n  board[7][1] = { type: PIECE_TYPES.CANNON, color: COLORS.RED };\n  board[7][7] = { type: PIECE_TYPES.CANNON, color: COLORS.RED };\n  board[6][0] = { type: PIECE_TYPES.SOLDIER, color: COLORS.RED };\n  board[6][2] = { type: PIECE_TYPES.SOLDIER, color: COLORS.RED };\n  board[6][4] = { type: PIECE_TYPES.SOLDIER, color: COLORS.RED };\n  board[6][6] = { type: PIECE_TYPES.SOLDIER, color: COLORS.RED };\n  board[6][8] = { type: PIECE_TYPES.SOLDIER, color: COLORS.RED };\n  \n  // 黑方（上方）\n  board[0][0] = { type: PIECE_TYPES.CHARIOT, color: COLORS.BLACK };\n  board[0][1] = { type: PIECE_TYPES.HORSE, color: COLORS.BLACK };\n  board[0][2] = { type: PIECE_TYPES.ELEPHANT, color: COLORS.BLACK };\n  board[0][3] = { type: PIECE_TYPES.ADVISOR, color: COLORS.BLACK };\n  board[0][4] = { type: PIECE_TYPES.GENERAL, color: COLORS.BLACK };\n  board[0][5] = { type: PIECE_TYPES.ADVISOR, color: COLORS.BLACK };\n  board[0][6] = { type: PIECE_TYPES.ELEPHANT, color: COLORS.BLACK };\n  board[0][7] = { type: PIECE_TYPES.HORSE, color: COLORS.BLACK };\n  board[0][8] = { type: PIECE_TYPES.CHARIOT, color: COLORS.BLACK };\n  board[2][1] = { type: PIECE_TYPES.CANNON, color: COLORS.BLACK };\n  board[2][7] = { type: PIECE_TYPES.CANNON, color: COLORS.BLACK };\n  board[3][0] = { type: PIECE_TYPES.SOLDIER, color: COLORS.BLACK };\n  board[3][2] = { type: PIECE_TYPES.SOLDIER, color: COLORS.BLACK };\n  board[3][4] = { type: PIECE_TYPES.SOLDIER, color: COLORS.BLACK };\n  board[3][6] = { type: PIECE_TYPES.SOLDIER, color: COLORS.BLACK };\n  board[3][8] = { type: PIECE_TYPES.SOLDIER, color: COLORS.BLACK };\n  \n  return board;\n};\n\n/**\n * 检查游戏是否结束\n * @param {Array} board - 棋盘状态\n * @param {String} currentTurn - 当前回合的颜色\n * @returns {Object} - { isGameOver, winner }\n */\nexport const checkGameEnd = (board, currentTurn) => {\n  const opponentColor = currentTurn === COLORS.RED ? COLORS.BLACK : COLORS.RED;\n  \n  // 检查对方是否被将军\n  if (isCheck(board, opponentColor)) {\n    // 检查对方是否有合法移动可解除将军\n    for (let fromRow = 0; fromRow < 10; fromRow++) {\n      for (let fromCol = 0; fromCol < 9; fromCol++) {\n        const piece = board[fromRow][fromCol];\n        if (piece && piece.color === opponentColor) {\n          // 尝试该棋子的所有可能移动\n          for (let toRow = 0; toRow < 10; toRow++) {\n            for (let toCol = 0; toCol < 9; toCol++) {\n              if (isValidMove(piece, board, fromRow, fromCol, toRow, toCol)) {\n                // 创建临时棋盘（深拷贝）\n                const tempBoard = JSON.parse(JSON.stringify(board));\n                \n                // 在临时棋盘上模拟移动\n                tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n                tempBoard[fromRow][fromCol] = null;\n                \n                // 检查移动后是否仍被将军\n                const stillInCheck = isCheck(tempBoard, opponentColor);\n                \n                if (!stillInCheck) {\n                  // 有解除将军的移动，游戏继续\n                  return { isGameOver: false, winner: null };\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // 无法解除将军，游戏结束，当前玩家胜利\n    return { isGameOver: true, winner: currentTurn };\n  }\n  \n  return { isGameOver: false, winner: null };\n}; "],"mappings":"AAAA;AACA;AACA;;AAEA;AACA,OAAO,MAAMA,WAAW,GAAG;EACzBC,OAAO,EAAE,SAAS;EAAG;EACrBC,OAAO,EAAE,SAAS;EAAG;EACrBC,QAAQ,EAAE,UAAU;EAAE;EACtBC,KAAK,EAAE,OAAO;EAAM;EACpBC,OAAO,EAAE,SAAS;EAAG;EACrBC,MAAM,EAAE,QAAQ;EAAK;EACrBC,OAAO,EAAE,SAAS,CAAG;AACvB,CAAC;;AAED;AACA,OAAO,MAAMC,MAAM,GAAG;EACpBC,GAAG,EAAE,KAAK;EACVC,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC3E;EACA,IAAIH,OAAO,GAAG,CAAC,IAAIA,OAAO,IAAI,EAAE,IAAIC,OAAO,GAAG,CAAC,IAAIA,OAAO,IAAI,CAAC,IAC3DC,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,EAAE,IAAIC,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,CAAC,EAAE;IACvD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIH,OAAO,KAAKE,KAAK,IAAID,OAAO,KAAKE,KAAK,EAAE;IAC1C,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAACL,KAAK,EAAE;IACV,OAAO,KAAK;EACd;;EAEA;EACA,IAAIC,KAAK,CAACG,KAAK,CAAC,CAACC,KAAK,CAAC,IAAIJ,KAAK,CAACG,KAAK,CAAC,CAACC,KAAK,CAAC,CAACC,KAAK,KAAKN,KAAK,CAACM,KAAK,EAAE;IACpE,OAAO,KAAK;EACd;;EAEA;EACA,QAAQN,KAAK,CAACO,IAAI;IAChB,KAAKnB,WAAW,CAACC,OAAO;MACtB,OAAOmB,kBAAkB,CAACP,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEL,KAAK,CAACM,KAAK,CAAC;IAC/E,KAAKlB,WAAW,CAACE,OAAO;MACtB,OAAOmB,kBAAkB,CAACR,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEL,KAAK,CAACM,KAAK,CAAC;IAC/E,KAAKlB,WAAW,CAACG,QAAQ;MACvB,OAAOmB,mBAAmB,CAACT,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEL,KAAK,CAACM,KAAK,CAAC;IAChF,KAAKlB,WAAW,CAACI,KAAK;MACpB,OAAOmB,gBAAgB,CAACV,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,CAAC;IAChE,KAAKjB,WAAW,CAACK,OAAO;MACtB,OAAOmB,kBAAkB,CAACX,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,CAAC;IAClE,KAAKjB,WAAW,CAACM,MAAM;MACrB,OAAOmB,iBAAiB,CAACZ,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,CAAC;IACjE,KAAKjB,WAAW,CAACO,OAAO;MACtB,OAAOmB,kBAAkB,CAACb,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEL,KAAK,CAACM,KAAK,CAAC;IAC/E;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA,MAAME,kBAAkB,GAAGA,CAACP,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC3E;EACA,MAAMS,UAAU,GAAGT,KAAK,KAAKV,MAAM,CAACC,GAAG,GACnCO,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,CAAE;EAAA,EACtDD,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,CAAC,CAAC;;EAE1D,IAAI,CAACU,UAAU,EAAE,OAAO,KAAK;;EAE7B;EACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,GAAGF,OAAO,CAAC;EACzC,MAAMiB,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACb,KAAK,GAAGF,OAAO,CAAC;EAEzC,OAAQa,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAC,IAAMH,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAE;AAC7E,CAAC;;AAED;AACA;AACA;AACA,MAAMV,kBAAkB,GAAGA,CAACR,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC3E;EACA,MAAMS,UAAU,GAAGT,KAAK,KAAKV,MAAM,CAACC,GAAG,GACnCO,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,CAAE;EAAA,EACtDD,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,CAAC,CAAC,CAAC;;EAE1D,IAAI,CAACU,UAAU,EAAE,OAAO,KAAK;;EAE7B;EACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,GAAGF,OAAO,CAAC;EACzC,MAAMiB,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACb,KAAK,GAAGF,OAAO,CAAC;EAEzC,OAAOa,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA,MAAMT,mBAAmB,GAAGA,CAACT,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC5E;EACA,MAAMc,gBAAgB,GAAGd,KAAK,KAAKV,MAAM,CAACC,GAAG,GACzCO,KAAK,GAAG,CAAC,CAAE;EAAA,EACXA,KAAK,GAAG,CAAC,CAAC,CAAC;;EAEf,IAAIgB,gBAAgB,EAAE,OAAO,KAAK;;EAElC;EACA,MAAMJ,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,GAAGF,OAAO,CAAC;EACzC,MAAMiB,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACb,KAAK,GAAGF,OAAO,CAAC;EAEzC,IAAIa,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAC,EAAE,OAAO,KAAK;;EAEhD;EACA,MAAME,MAAM,GAAG,CAACnB,OAAO,GAAGE,KAAK,IAAI,CAAC;EACpC,MAAMkB,MAAM,GAAG,CAACnB,OAAO,GAAGE,KAAK,IAAI,CAAC;EAEpC,OAAO,CAACJ,KAAK,CAACoB,MAAM,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA,MAAMX,gBAAgB,GAAGA,CAACV,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAClE,MAAMW,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,GAAGF,OAAO,CAAC;EACzC,MAAMiB,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACb,KAAK,GAAGF,OAAO,CAAC;;EAEzC;EACA,IAAI,EAAGa,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAC,IAAMH,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAE,CAAC,EAAE;IAC3E,OAAO,KAAK;EACd;;EAEA;EACA,IAAII,MAAM,GAAGrB,OAAO;EACpB,IAAIsB,MAAM,GAAGrB,OAAO;EAEpB,IAAIa,OAAO,KAAK,CAAC,EAAE;IACjB;IACAO,MAAM,GAAGrB,OAAO,IAAIE,KAAK,GAAGF,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC/C,CAAC,MAAM;IACL;IACAsB,MAAM,GAAGrB,OAAO,IAAIE,KAAK,GAAGF,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC/C;EAEA,OAAO,CAACF,KAAK,CAACsB,MAAM,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA,MAAMZ,kBAAkB,GAAGA,CAACX,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACpE;EACA,IAAIH,OAAO,KAAKE,KAAK,IAAID,OAAO,KAAKE,KAAK,EAAE;IAC1C,OAAO,KAAK;EACd;;EAEA;EACA,IAAIH,OAAO,KAAKE,KAAK,EAAE;IACrB;IACA,MAAMqB,MAAM,GAAGR,IAAI,CAACS,GAAG,CAACvB,OAAO,EAAEE,KAAK,CAAC;IACvC,MAAMsB,MAAM,GAAGV,IAAI,CAACW,GAAG,CAACzB,OAAO,EAAEE,KAAK,CAAC;IAEvC,KAAK,IAAIwB,GAAG,GAAGJ,MAAM,GAAG,CAAC,EAAEI,GAAG,GAAGF,MAAM,EAAEE,GAAG,EAAE,EAAE;MAC9C,IAAI5B,KAAK,CAACC,OAAO,CAAC,CAAC2B,GAAG,CAAC,EAAE;QACvB,OAAO,KAAK,CAAC,CAAC;MAChB;IACF;EACF,CAAC,MAAM;IACL;IACA,MAAMC,MAAM,GAAGb,IAAI,CAACS,GAAG,CAACxB,OAAO,EAAEE,KAAK,CAAC;IACvC,MAAM2B,MAAM,GAAGd,IAAI,CAACW,GAAG,CAAC1B,OAAO,EAAEE,KAAK,CAAC;IAEvC,KAAK,IAAI4B,GAAG,GAAGF,MAAM,GAAG,CAAC,EAAEE,GAAG,GAAGD,MAAM,EAAEC,GAAG,EAAE,EAAE;MAC9C,IAAI/B,KAAK,CAAC+B,GAAG,CAAC,CAAC7B,OAAO,CAAC,EAAE;QACvB,OAAO,KAAK,CAAC,CAAC;MAChB;IACF;EACF;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA,MAAMU,iBAAiB,GAAGA,CAACZ,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACnE;EACA,IAAIH,OAAO,KAAKE,KAAK,IAAID,OAAO,KAAKE,KAAK,EAAE;IAC1C,OAAO,KAAK;EACd;EAEA,IAAI4B,UAAU,GAAG,CAAC,CAAC,CAAC;;EAEpB,IAAI/B,OAAO,KAAKE,KAAK,EAAE;IACrB;IACA,MAAMqB,MAAM,GAAGR,IAAI,CAACS,GAAG,CAACvB,OAAO,EAAEE,KAAK,CAAC;IACvC,MAAMsB,MAAM,GAAGV,IAAI,CAACW,GAAG,CAACzB,OAAO,EAAEE,KAAK,CAAC;IAEvC,KAAK,IAAIwB,GAAG,GAAGJ,MAAM,GAAG,CAAC,EAAEI,GAAG,GAAGF,MAAM,EAAEE,GAAG,EAAE,EAAE;MAC9C,IAAI5B,KAAK,CAACC,OAAO,CAAC,CAAC2B,GAAG,CAAC,EAAE;QACvBI,UAAU,EAAE;MACd;IACF;EACF,CAAC,MAAM;IACL;IACA,MAAMH,MAAM,GAAGb,IAAI,CAACS,GAAG,CAACxB,OAAO,EAAEE,KAAK,CAAC;IACvC,MAAM2B,MAAM,GAAGd,IAAI,CAACW,GAAG,CAAC1B,OAAO,EAAEE,KAAK,CAAC;IAEvC,KAAK,IAAI4B,GAAG,GAAGF,MAAM,GAAG,CAAC,EAAEE,GAAG,GAAGD,MAAM,EAAEC,GAAG,EAAE,EAAE;MAC9C,IAAI/B,KAAK,CAAC+B,GAAG,CAAC,CAAC7B,OAAO,CAAC,EAAE;QACvB8B,UAAU,EAAE;MACd;IACF;EACF;;EAEA;EACA,IAAIhC,KAAK,CAACG,KAAK,CAAC,CAACC,KAAK,CAAC,EAAE;IACvB,OAAO4B,UAAU,KAAK,CAAC;EACzB;;EAEA;EACA,OAAOA,UAAU,KAAK,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA,MAAMnB,kBAAkB,GAAGA,CAACb,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC3E,MAAMU,OAAO,GAAGZ,KAAK,GAAGF,OAAO;EAC/B,MAAMiB,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACb,KAAK,GAAGF,OAAO,CAAC;;EAEzC;EACA,IAAIgB,OAAO,GAAG,CAAC,IAAIF,IAAI,CAACC,GAAG,CAACF,OAAO,CAAC,GAAG,CAAC,IAAKG,OAAO,KAAK,CAAC,IAAIH,OAAO,KAAK,CAAE,EAAE;IAC5E,OAAO,KAAK;EACd;EAEA,IAAIV,KAAK,KAAKV,MAAM,CAACC,GAAG,EAAE;IACxB;IACA,IAAIK,OAAO,IAAI,CAAC,EAAE;MAChB;MACA,OAAOc,OAAO,KAAK,CAAC,CAAC,IAAIG,OAAO,KAAK,CAAC;IACxC,CAAC,MAAM;MACL;MACA,OAAOH,OAAO,KAAK,CAAC,CAAC,IAAKA,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAE;IAC3D;EACF,CAAC,MAAM;IACL;IACA,IAAIjB,OAAO,IAAI,CAAC,EAAE;MAChB;MACA,OAAOc,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAC;IACvC,CAAC,MAAM;MACL;MACA,OAAOH,OAAO,KAAK,CAAC,IAAKA,OAAO,KAAK,CAAC,IAAIG,OAAO,KAAK,CAAE;IAC1D;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMe,OAAO,GAAGA,CAACjC,KAAK,EAAEkC,SAAS,KAAK;EAC3C;EACA,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAEhB,KAAK,IAAIL,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,EAAE,EAAEA,GAAG,EAAE,EAAE;IACjC,KAAK,IAAIH,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,MAAM7B,KAAK,GAAGC,KAAK,CAAC+B,GAAG,CAAC,CAACH,GAAG,CAAC;MAC7B,IAAI7B,KAAK,IAAIA,KAAK,CAACO,IAAI,KAAKnB,WAAW,CAACC,OAAO,IAAIW,KAAK,CAACM,KAAK,KAAK6B,SAAS,EAAE;QAC5EC,OAAO,GAAGJ,GAAG;QACbK,OAAO,GAAGR,GAAG;QACb;MACF;IACF;IACA,IAAIO,OAAO,KAAK,CAAC,CAAC,EAAE;EACtB;;EAEA;EACA,IAAIA,OAAO,KAAK,CAAC,CAAC,IAAIC,OAAO,KAAK,CAAC,CAAC,EAAE;IACpC,OAAO,KAAK;EACd;;EAEA;EACA,MAAMC,aAAa,GAAGH,SAAS,KAAKvC,MAAM,CAACC,GAAG,GAAGD,MAAM,CAACE,KAAK,GAAGF,MAAM,CAACC,GAAG;EAE1E,KAAK,IAAImC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,EAAE,EAAEA,GAAG,EAAE,EAAE;IACjC,KAAK,IAAIH,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,MAAM7B,KAAK,GAAGC,KAAK,CAAC+B,GAAG,CAAC,CAACH,GAAG,CAAC;MAC7B,IAAI7B,KAAK,IAAIA,KAAK,CAACM,KAAK,KAAKgC,aAAa,EAAE;QAC1C,IAAIvC,WAAW,CAACC,KAAK,EAAEC,KAAK,EAAE+B,GAAG,EAAEH,GAAG,EAAEO,OAAO,EAAEC,OAAO,CAAC,EAAE;UACzD,OAAO,IAAI,CAAC,CAAC;QACf;MACF;IACF;EACF;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAME,gBAAgB,GAAItC,KAAK,IAAK;EACzC,IAAIuC,aAAa,GAAG,CAAC,CAAC;EACtB,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,IAAIC,aAAa,GAAG,CAAC,CAAC;EACtB,IAAIC,eAAe,GAAG,CAAC,CAAC;;EAExB;EACA,KAAK,IAAIX,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,EAAE,EAAEA,GAAG,EAAE,EAAE;IACjC,KAAK,IAAIH,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,MAAM7B,KAAK,GAAGC,KAAK,CAAC+B,GAAG,CAAC,CAACH,GAAG,CAAC;MAC7B,IAAI7B,KAAK,IAAIA,KAAK,CAACO,IAAI,KAAKnB,WAAW,CAACC,OAAO,EAAE;QAC/C,IAAIW,KAAK,CAACM,KAAK,KAAKV,MAAM,CAACC,GAAG,EAAE;UAC9B6C,aAAa,GAAGV,GAAG;UACnBQ,aAAa,GAAGX,GAAG;QACrB,CAAC,MAAM;UACLc,eAAe,GAAGX,GAAG;UACrBS,eAAe,GAAGZ,GAAG;QACvB;MACF;IACF;EACF;;EAEA;EACA,IAAIa,aAAa,KAAK,CAAC,CAAC,IAAIC,eAAe,KAAK,CAAC,CAAC,EAAE;IAClD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIH,aAAa,KAAKC,eAAe,EAAE;IACrC;IACA,MAAMX,MAAM,GAAGb,IAAI,CAACS,GAAG,CAACgB,aAAa,EAAEC,eAAe,CAAC;IACvD,MAAMZ,MAAM,GAAGd,IAAI,CAACW,GAAG,CAACc,aAAa,EAAEC,eAAe,CAAC;;IAEvD;IACA,IAAIC,eAAe,GAAG,KAAK;IAC3B,KAAK,IAAIZ,GAAG,GAAGF,MAAM,GAAG,CAAC,EAAEE,GAAG,GAAGD,MAAM,EAAEC,GAAG,EAAE,EAAE;MAC9C,IAAI/B,KAAK,CAAC+B,GAAG,CAAC,CAACQ,aAAa,CAAC,EAAE;QAC7BI,eAAe,GAAG,IAAI;QACtB;MACF;IACF;IAEA,OAAO,CAACA,eAAe,CAAC,CAAC;EAC3B;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAGA,CAAA,KAAM;EACnC,MAAM5C,KAAK,GAAG6C,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;;EAE7D;EACA9C,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACK,OAAO;IAAEa,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACI,KAAK;IAAEc,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC5DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACG,QAAQ;IAAEe,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC/DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACE,OAAO;IAAEgB,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACC,OAAO;IAAEiB,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACE,OAAO;IAAEgB,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACG,QAAQ;IAAEe,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC/DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACI,KAAK;IAAEc,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC5DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACK,OAAO;IAAEa,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACM,MAAM;IAAEY,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC7DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACM,MAAM;IAAEY,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC7DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;EAC9DI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACC;EAAI,CAAC;;EAE9D;EACAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACK,OAAO;IAAEa,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACI,KAAK;IAAEc,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAC9DG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACG,QAAQ;IAAEe,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EACjEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACE,OAAO;IAAEgB,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACC,OAAO;IAAEiB,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACE,OAAO;IAAEgB,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACG,QAAQ;IAAEe,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EACjEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACI,KAAK;IAAEc,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAC9DG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACK,OAAO;IAAEa,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACM,MAAM;IAAEY,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAC/DG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACM,MAAM;IAAEY,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAC/DG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAChEG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IAAEM,IAAI,EAAEnB,WAAW,CAACO,OAAO;IAAEW,KAAK,EAAEV,MAAM,CAACE;EAAM,CAAC;EAEhE,OAAOG,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMgD,YAAY,GAAGA,CAAChD,KAAK,EAAEiD,WAAW,KAAK;EAClD,MAAMZ,aAAa,GAAGY,WAAW,KAAKtD,MAAM,CAACC,GAAG,GAAGD,MAAM,CAACE,KAAK,GAAGF,MAAM,CAACC,GAAG;;EAE5E;EACA,IAAIqC,OAAO,CAACjC,KAAK,EAAEqC,aAAa,CAAC,EAAE;IACjC;IACA,KAAK,IAAIpC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,EAAE,EAAEA,OAAO,EAAE,EAAE;MAC7C,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,CAAC,EAAEA,OAAO,EAAE,EAAE;QAC5C,MAAMH,KAAK,GAAGC,KAAK,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC;QACrC,IAAIH,KAAK,IAAIA,KAAK,CAACM,KAAK,KAAKgC,aAAa,EAAE;UAC1C;UACA,KAAK,IAAIlC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,EAAE,EAAEA,KAAK,EAAE,EAAE;YACvC,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,EAAE,EAAE;cACtC,IAAIN,WAAW,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,CAAC,EAAE;gBAC7D;gBACA,MAAM8C,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACrD,KAAK,CAAC,CAAC;;gBAEnD;gBACAkD,SAAS,CAAC/C,KAAK,CAAC,CAACC,KAAK,CAAC,GAAG8C,SAAS,CAACjD,OAAO,CAAC,CAACC,OAAO,CAAC;gBACrDgD,SAAS,CAACjD,OAAO,CAAC,CAACC,OAAO,CAAC,GAAG,IAAI;;gBAElC;gBACA,MAAMoD,YAAY,GAAGrB,OAAO,CAACiB,SAAS,EAAEb,aAAa,CAAC;gBAEtD,IAAI,CAACiB,YAAY,EAAE;kBACjB;kBACA,OAAO;oBAAEC,UAAU,EAAE,KAAK;oBAAEC,MAAM,EAAE;kBAAK,CAAC;gBAC5C;cACF;YACF;UACF;QACF;MACF;IACF;;IAEA;IACA,OAAO;MAAED,UAAU,EAAE,IAAI;MAAEC,MAAM,EAAEP;IAAY,CAAC;EAClD;EAEA,OAAO;IAAEM,UAAU,EAAE,KAAK;IAAEC,MAAM,EAAE;EAAK,CAAC;AAC5C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}